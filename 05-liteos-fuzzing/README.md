# Perry LiteOS Fuzzing Experiment
This is the experiment described in Section 6.2 ("Fuzzing RTOS for Vulnerabilities") of our paper, where we use `AFL` to fuzz `LiteOS` with hardware models generated by `Perry`. The directories [`in_json`](./in_json/) and [`in_rand`](./in_rand/) contain the used seeds. The directories `lwm2m_*` and `mqtt_*` contain the compiled fuzz targets listed in Table 6. These targets are compiled with KASAN and UBSAN. Each target is fuzzed once for 6 hours.

> We are unable to release the source code of these harnesses according to our agreement with Huawei.

## Preparation
You **MUST** finish the experiments in [`01-efficiency`](../01-efficiency/) to generate hardware models.

## Estimated Time Consumption
* 66 compute-hours at most, 6 compute-hours if your machine has >=11 cores.
* 5 human-minutes

> 11 targets, 6 compute-hours per target -> 66 compute-hours at most

## Running the experiment
0. Change directory:
```shell
cd perry-experiments/05-liteos-fuzzing
```

1. Prepare the **HOST** machine for fuzzing. Please note that the following commands should be executed on the **HOST** machine:
```shell
wget https://raw.githubusercontent.com/AFLplusplus/AFLplusplus/stable/afl-system-config
chmod +x afl-system-config
sudo ./afl-system-config
```

3. Patch QEMU to integrate `stm32f769` models generated by `Perry` and rebuild QEMU. If you are running within a container, `FUZZ_QEMU_DIR=/root/qemu-system-fuzzing PERRY_OUTPUT_DIR=/root/perry-experiments/01-efficiency/exp-1`.
```shell
FUZZ_QEMU_DIR=/path/to/qemu-system-fuzzing PERRY_OUTPUT_DIR=/path/to/perry/output_directory ./prepare_qemu_fuzz.sh
```

4. Run the fuzzing experiment. Note that the runner script will try to leverage every CPU on the machine. If you are running within a container, `AFL_PATH=/root/AFL QEMU_PATH=/root/qemu-system-fuzzing`.
```shell
AFL_PATH=/path/to/AFL QEMU_PATH=/path/to/qemu-system-fuzzing python run.py
```

## Expected Results
The results are stored in `result.csv`, and the numbers should be comparable with those listed in Talbe 6 of the paper. Here are the explanations of the numbers listed in `result.csv`:
* **target**: the fuzzed target
* **speed**: the number of fuzzing executions per second
* **execs**: the total number of fuzzing executions
* **paths**: the total number of paths explored during fuzzing
* **crashes**: the total number of crashes triggered during fuzzing
* **hangs**: the total number of hangs triggered during fuzzing

## Triaging Crashes/Hangs
We have provided a script `triage.py` to triage crashes/hangs. `QEMU_PATH=/root/qemu-system-fuzzing` if you are using the container.
```shell
# QEMU_PATH=/path/to/qemu-system-fuzzing python triage.py -h
usage: triage.py [-h] --target
                 {lwm2m_coap_parse_message,lwm2m_data_parse_json,lwm2m_data_parse_tlv,mqtt_ack,mqtt_connack,mqtt_connect,mqtt_pub,mqtt_suback,mqtt_subscribe,mqtt_unsuback,mqtt_unsubscribe}
                 [-d]
                 input

positional arguments:
  input                 the input to triage

optional arguments:
  -h, --help            show this help message and exit
  --target {lwm2m_coap_parse_message,lwm2m_data_parse_json,lwm2m_data_parse_tlv,mqtt_ack,mqtt_connack,mqtt_connect,mqtt_pub,mqtt_suback,mqtt_subscribe,mqtt_unsuback,mqtt_unsubscribe}
                        the fuzz target
  -d, --debug           debug with GDB
```

For example, the following command triages a crashing input found while fuzzing `lwm2m_coap_parse_message`.

```shell
> QEMU_PATH=/root/qemu-system-fuzzing python triage.py lwm2m_coap_parse_message/out0/crashes/id\:000008\,sig\:06\,src\:000000\,op\:havoc\,rep\:16 --target lwm2m_coap_parse_message

********Hello Huawei LiteOS********

LiteOS Kernel Version : 5.1.0
build date : Nov 24 2023 14:43:56

**********************************
LOS_MEMInit size:206f140
Mem Init size:206f140
OsAppInit
LOS_MEMInit size:400000
Mem Init size:400000
cpu 0 entering scheduler
app init!
KASAN failure: addr 0x2041572e, read, size: 1
Bug type: Heap Overflow
runTask->taskName = app_Task
runTask->taskId = 2
sp:0x204153f0
*******backtrace begin*******
traceback 1 -- lr = 0x0802663e -- fp = 0x080265f8
traceback 2 -- lr = 0x0800f092 -- fp = 0x08026624
traceback 3 -- lr = 0x080189c6 -- fp = 0x0800f004
traceback 4 -- lr = 0x08019964 -- fp = 0x0801898c
traceback 5 -- lr = 0x08070384 -- fp = 0x08019794
traceback 6 -- lr = 0x08025a54 -- fp = 0x0806f9f4
traceback 7 -- lr = 0x08018b8a -- fp = 0x08018830
traceback 8 -- lr = 0x08006d90 -- fp = 0x08006d18
traceback 9 -- lr = 0x08025b24 -- fp = 0x08025a04
traceback 10 -- lr = 0x0800b6b2 -- fp = 0x08025a8c
traceback 11 -- lr = 0x080266e2 -- fp = 0x0800b508
*******backtrace end*******
```

Our KASAN/UBSAN runtime outputs can help you locate the triggered bug. If you want to debug the input, use the `-d` option, this will make QEMU open a `gdb` server at `localhost:1234`. At this point, you can attach to the `gdb` server and start debugging.

In shell A, execute:
```shell
> QEMU_PATH=/path/to/qemu-system-fuzzing python triage.py [input] --target [target] -d
```

In shell B, execute:
```shell
arm-none-eabi-gdb [target]/Huawei_LiteOS.elf
(gdb) target remote localhost:1234
```