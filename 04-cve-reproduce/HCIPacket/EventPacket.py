import struct

from .Packet import Packet, PacketType
from .Address import Address

from enum import IntEnum

from typing import List


class EventPacket(Packet):

    def __init__(self, evt_code, param) -> None:
        super().__init__(PacketType.EVENT,
                         struct.pack("BB", evt_code, len(param)) + param)

    @property
    def evt_code(self):
        return self.data[0]

    @property
    def param(self):
        return self.data[2:]

    @property
    def param_len(self):
        return self.data[1]


class EventCode(IntEnum):
    LE_META = 0x3E


class LEMetaSubventCode(IntEnum):
    HCI_LE_Connection_Complete = 0x01
    HCI_LE_Extended_Advertising_Report = 0x0D


class LEMetaEvent(EventPacket):

    def __init__(self, subevt_code, rem_param) -> None:
        super().__init__(EventCode.LE_META,
                         struct.pack("B", subevt_code) + rem_param)

    @property
    def subevt_code(self):
        return self.param[0]


class HciLeExtendedAdvertisingReportEvent(LEMetaEvent):

    EVENT_TYPE_CONNECTABLE_ADVERTISING = 1
    EVENT_TYPE_SCANNABLE_ADVERTISING = 2
    EVENT_TYPE_DIRECTED_ADVERTISING = 4
    EVENT_TYPE_SCAN_RESPONSE = 8
    EVENT_TYPE_LEGACY_ADVERTISING_PDU_USED = 16
    EVENT_TYPE_DATA_COMPLETE = 0
    EVENT_TYPE_MORE_DATA = 32
    EVENT_TYPE_DATA_TRUNCATED = 64

    class AddressType(IntEnum):
        PUBLIC_DEVICE = 0x00
        RANDOM_DEVICE = 0x01
        PUBLIC_IDENTITY = 0x02
        RANDOM_IDENTITY = 0x03
        ANONYMOUS = 0xFF

    class PrimaryPHY(IntEnum):
        LE_1M = 0x01
        LE_CODED = 0x03

    class SecondaryPHY(IntEnum):
        NONE = 0x00
        LE_1M = 0x01
        LE_2M = 0x02
        LE_CODED = 0x03

    class DirectAddressType(IntEnum):
        PUBLIC_DEVICE = 0x00
        NON_RESOLVABLE_PRIVATE = 0x01
        RESOLVABLE_PRIVATE_02 = 0x02
        RESOLVABLE_PRIVATE_13 = 0x03
        RESOLVABLE_PRIVATE_NONE = 0xFE

    class Report():

        def __init__(self, event_type, address_type, address: Address,
                     primary_PHY, secondary_PHY, advertising_SID, tx_power,
                     rssi, periodic_advertising_interval, direct_address_type,
                     direct_address: Address, data) -> None:
            self.event_type = event_type
            self.address_type = address_type
            self.address = address
            self.primary_PHY = primary_PHY
            self.secondary_PHY = secondary_PHY
            self.advertising_SID = advertising_SID
            self.tx_power = tx_power
            self.rssi = rssi
            self.periodic_advertising_interval = periodic_advertising_interval
            self.direct_address_type = direct_address_type
            self.direct_address = direct_address
            self.data = data

    def __init__(self, reports: List[Report]) -> None:
        num_report = len(reports)
        payload = struct.pack("B", num_report)
        payload += struct.pack("<".join("H" * num_report),
                               *[r.event_type for r in reports])
        payload += struct.pack("B" * num_report,
                               *[r.address_type for r in reports])
        payload += b''.join([r.address.bytes for r in reports])
        payload += struct.pack("B" * num_report,
                               *[r.primary_PHY for r in reports])
        payload += struct.pack("B" * num_report,
                               *[r.secondary_PHY for r in reports])
        payload += struct.pack("B" * num_report,
                               *[r.advertising_SID for r in reports])
        payload += struct.pack("B" * num_report,
                               *[r.tx_power for r in reports])
        payload += struct.pack("B" * num_report, *[r.rssi for r in reports])
        payload += struct.pack(
            "<".join("H" * num_report),
            *[r.periodic_advertising_interval for r in reports])
        payload += struct.pack("B" * num_report,
                               *[r.direct_address_type for r in reports])
        payload += b''.join([r.direct_address.bytes for r in reports])
        payload += struct.pack("B" * num_report,
                               *[len(r.data) for r in reports])
        payload += b''.join([r.data for r in reports])
        super().__init__(LEMetaSubventCode.HCI_LE_Extended_Advertising_Report,
                         payload)

    @property
    def report(self):
        num_report = self.param[1]
        payload = self.param[2:]
        event_type = struct.unpack("<".join("H" * num_report),
                                   payload[:2 * num_report])
        payload = payload[2 * num_report:]
        address_type = struct.unpack("B" * num_report, payload[:num_report])
        payload = payload[num_report:]
        address = [
            Address(r)
            for r in struct.unpack("6s" * num_report, payload[:6 * num_report])
        ]
        payload = payload[6 * num_report:]
        primary_PHY = struct.unpack("B" * num_report, payload[:num_report])
        payload = payload[num_report:]
        secondary_PHY = struct.unpack("B" * num_report, payload[:num_report])
        payload = payload[num_report:]
        advertising_SID = struct.unpack("B" * num_report, payload[:num_report])
        payload = payload[num_report:]
        tx_power = struct.unpack("B" * num_report, payload[:num_report])
        payload = payload[num_report:]
        rssi = struct.unpack("B" * num_report, payload[:num_report])
        payload = payload[num_report:]
        periodic_advertising_interval = struct.unpack(
            "<".join("H" * num_report), payload[:2 * num_report])
        payload = payload[2 * num_report:]
        direct_address_type = struct.unpack("B" * num_report,
                                            payload[:num_report])
        payload = payload[num_report:]
        direct_address = [
            Address(r)
            for r in struct.unpack("6s" * num_report, payload[:6 * num_report])
        ]
        payload = payload[6 * num_report:]
        data_len = struct.unpack("B" * num_report, payload[:num_report])
        payload = payload[num_report:]
        data = []
        for l in data_len:
            data.append(payload[:l])
            payload = payload[l:]
        report = []
        for i in range(num_report):
            report.append(
                HciLeExtendedAdvertisingReportEvent.Report(
                    event_type[i], address_type[i], address[i], primary_PHY[i],
                    secondary_PHY[i], advertising_SID[i], tx_power[i], rssi[i],
                    periodic_advertising_interval[i], direct_address_type[i],
                    direct_address[i], data[i]))
        return report


class ADType(IntEnum):
    PBADV = 0x29


class ADStructure():

    def __init__(self, type: ADType, data) -> None:
        self._type = type
        self._data = data

    @property
    def type(self):
        return self._type

    @property
    def data(self):
        return self._data

    @property
    def length(self):
        return 1 + len(self.data)

    @property
    def bytes(self):
        return struct.pack("BB", self.length, self.type) + self.data


class PBADV(ADStructure):

    def __init__(self, link_id, transaction_number,
                 generic_provisioning_PDU) -> None:
        super().__init__(
            ADType.PBADV,
            struct.pack(">IB", link_id, transaction_number) +
            generic_provisioning_PDU)

    @property
    def link_id(self):
        return struct.unpack(">I", self.data[:4])[0]

    @property
    def transaction_number(self):
        return self.data[4]

    @property
    def generic_provisioning_PDU(self):
        return self.data[5:]


class GenericProvisioningPDU(PBADV):

    def __init__(self, link_id, transaction_number, gpc, payload) -> None:
        super().__init__(link_id, transaction_number, gpc + payload)

    def gpcf(self):
        return (self.generic_provisioning_PDU[0] & 0x03)


class TransactionStartPDU(GenericProvisioningPDU):

    def __init__(self, link_id, transaction_number, segN, total_len, FCS,
                 data) -> None:
        super().__init__(
            link_id, transaction_number,
            struct.pack(">BHB", ((segN << 2) | 0x00), total_len, FCS), data)

    @property
    def segN(self):
        return (self.generic_provisioning_PDU[0] >> 2)

    @property
    def total_len(self):
        return struct.unpack(">H", self.generic_provisioning_PDU[1:3])[0]

    @property
    def FCS(self):
        return self.generic_provisioning_PDU[3]

    @property
    def payload(self):
        return self.generic_provisioning_PDU[4:]


class TransactionContinuePDU(GenericProvisioningPDU):

    def __init__(self, link_id, transaction_number, segment_index,
                 data) -> None:
        super().__init__(link_id, transaction_number,
                         struct.pack("B", ((segment_index << 2) | 0x02)), data)

    @property
    def segment_index(self):
        return (self.generic_provisioning_PDU[0] >> 2)

    @property
    def payload(self):
        return self.generic_provisioning_PDU[1:]


class BearerOpcode(IntEnum):
    LINK_OPEN = 0x00


class ProvisioningBearerControlPDU(GenericProvisioningPDU):

    def __init__(self, link_id, transaction_number,
                 bearer_opcode: BearerOpcode, param) -> None:
        super().__init__(link_id, transaction_number,
                         struct.pack("B", ((bearer_opcode << 2) | 0x03)),
                         param)

    @property
    def bearer_opcode(self):
        return (self.generic_provisioning_PDU[0] >> 2)


class ProvisioningBearerControlLinkOpen(ProvisioningBearerControlPDU):

    def __init__(self, link_id, transaction_number, uuid) -> None:
        super().__init__(link_id, transaction_number, BearerOpcode.LINK_OPEN,
                         uuid)
    
    @property
    def uuid(self):
        return self.generic_provisioning_PDU[1:17]
