import os
import random
import struct
import socket
import select
import argparse

from pathlib import Path
from loguru import logger

from time import sleep
from typing import Tuple

ROOT = Path(os.path.dirname(os.path.abspath(__file__)))

def _parse_command(buf: bytes) -> Tuple[bool, int]:
    buf = buf[1:]
    buf_len = len(buf)
    if buf_len < 3:
        return False, 0
    total_len = 3 + buf[2]
    if buf_len >= total_len:
        return True, total_len + 1
    return False, 0


def _parse_acl_data(buf: bytes) -> Tuple[bool, int]:
    buf = buf[1:]
    buf_len = len(buf)
    if buf_len < 4:
        return False, 0
    total_len = 4 + struct.unpack("<H", buf[2:4])[0]
    if buf_len >= total_len:
        return True, total_len + 1
    return False, 0


def _parse_sync_data(buf: bytes) -> Tuple[bool, int]:
    buf = buf[1:]
    buf_len = len(buf)
    if buf_len < 3:
        return False, 0
    total_len = 3 + buf[2]
    if buf_len >= total_len:
        return True, total_len + 1
    return False, 0


def _parse_event(buf: bytes) -> Tuple[bool, int]:
    buf = buf[1:]
    buf_len = len(buf)
    if buf_len < 2:
        return False, 0
    total_len = 2 + buf[1]
    if buf_len >= total_len:
        return True, total_len + 1
    return False, 0


def _parse_iso(buf: bytes) -> Tuple[bool, int]:
    buf = buf[1:]
    buf_len = len(buf)
    if buf_len < 4:
        return False, 0
    total_len = 4 + (struct.unpack("<H", buf[2:4])[0] & ((1 << 14) - 1))
    if buf_len >= total_len:
        return True, total_len + 1
    return False, 0


def try_parse(buf: bytes) -> Tuple[bool, int]:
    if len(buf) == 0:
        return False, 0
    p_type = buf[0]
    p_content = buf[0:]
    if p_type == 1:
        return _parse_command(p_content)
    elif p_type == 2:
        return _parse_acl_data(p_content)
    elif p_type == 3:
        return _parse_sync_data(p_content)
    elif p_type == 4:
        return _parse_event(p_content)
    elif p_type == 5:
        return _parse_iso(p_content)
    logger.error("Unhandled packet type: {}, abort", p_type)
    exit(10)


def write_packet(fd, packet, wait_time):
    if wait_time is None:
        wait_time = 0.02
    lower = wait_time
    upper = wait_time * 1.5
    for bt in packet:
        b = struct.pack("B", bt)
        os.write(fd, b)
        sleep(random.uniform(lower, upper))

def main(args):
    # setup bluetooth socket
    bs = socket.socket(socket.AF_BLUETOOTH, socket.SOCK_RAW,
                       socket.BTPROTO_HCI)  # noqa: E501
    bs.setsockopt(socket.SOL_HCI, socket.HCI_DATA_DIR, 1)
    bs.setsockopt(socket.SOL_HCI, socket.HCI_TIME_STAMP, 1)
    bs.setsockopt(
        socket.SOL_HCI, socket.HCI_FILTER,
        struct.pack(
            "IIIh2x", 0xffffffff, 0xffffffff, 0xffffffff,
            0))  # type mask, event mask, event mask, opcode  # noqa: E501
    bs.setblocking(False)
    bs.bind((0, ))

    # setup in pipe
    in_pipe = os.open(args.in_pipe, os.O_WRONLY | os.O_SYNC)

    # setup out pipe
    out_pipe = os.open(args.out_pipe, os.O_RDONLY | os.O_NONBLOCK)

    # setup injection fd, if any
    has_inject_fd = False
    if args.injection_file:
        inject_fd = os.open(args.injection_file, os.O_RDONLY | os.O_NONBLOCK)
        has_inject_fd = True

    # create epoll
    epoll = select.epoll()

    # recv and send for bs
    epoll.register(bs.fileno(), select.EPOLLIN | select.EPOLLOUT)
    # recv from out_pipe
    epoll.register(out_pipe, select.EPOLLIN)
    # recv from inject_fd, if any
    if has_inject_fd:
        epoll.register(inject_fd, select.EPOLLIN)
        
    try:
        # `down` means host -> controller
        down_buf = b''
        down_queue = []
        # `up` means controller -> host
        up_buf = b''
        up_queue = []
        # injected packets
        inject_buf = b''
        while True:
            events = epoll.poll(1)
            for fd, evt in events:
                if has_inject_fd and fd == inject_fd:
                    # inject_fd
                    if evt & select.EPOLLIN:
                        inject_buf += os.read(inject_fd, 1024)
                        success, blen = try_parse(inject_buf)
                        if success:
                            packet = inject_buf[:blen]
                            inject_buf = inject_buf[blen:]
                            up_queue.append(packet)
                            if args.verbose:
                                print("INJECTED".center(30, '-'))
                                HCI_Hdr(packet).show()
                    elif evt & select.EPOLLHUP:
                        # peer died?
                        logger.info("[*] injection fd closed")
                        has_inject_fd = False
                        os.close(inject_fd)
                    else:
                        raise RuntimeError(
                            "epoll event {} is not handled on out pipe".format(
                                evt))
                elif fd == bs.fileno():
                    if evt & select.EPOLLIN:
                        # ready to be read, read packets and send them up
                        up_buf += bs.recv(1024)
                        while True:
                            success, blen = try_parse(up_buf)
                            if success:
                                packet = up_buf[:blen]
                                up_buf = up_buf[blen:]
                                # ignore command packet
                                if packet[0] != 1:
                                    up_queue.append(packet)
                            else:
                                break
                        
                        # write one packet
                        if len(up_queue) > 0:
                            packet = up_queue.pop(0)
                            write_packet(in_pipe, packet, args.wait_time)
                            if args.verbose:
                                print("Controller to Host".center(45, '-'))
                                HCI_Hdr(packet).show()
                    elif evt & select.EPOLLOUT:
                        # ready to be write, send one packet down
                        if len(down_queue) > 0:
                            packet = down_queue.pop(0)
                            bs.send(packet)
                            if args.verbose:
                                print("Host to Controller".center(45, '-'))
                                HCI_Hdr(packet).show()
                    else:
                        raise RuntimeError(
                            "epoll event {} is not handled on bluetooth socket"
                            .format(evt))
                elif fd == out_pipe:
                    # out_pipe
                    if evt & select.EPOLLIN:
                        down_buf += os.read(out_pipe, 1024)
                        success, blen = try_parse(down_buf)
                        if success:
                            packet = down_buf[:blen]
                            down_buf = down_buf[blen:]
                            down_queue.append(packet)
                    elif evt & select.EPOLLHUP:
                        # peer died?
                        logger.info("[*] broken pipe, peer died?")
                        return
                    else:
                        raise RuntimeError(
                            "epoll event {} is not handled on out pipe".format(
                                evt))
                else:
                    raise RuntimeError(
                        "epoll fd {} is not handled ".format(fd))

    except KeyboardInterrupt:
        raise(KeyboardInterrupt)
    finally:
        epoll.unregister(out_pipe)
        epoll.unregister(bs.fileno())
        epoll.close()
        os.close(out_pipe)
        os.close(in_pipe)
        bs.close()
        if has_inject_fd:
            os.close(inject_fd)
            has_inject_fd = False


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Simple MITM Proxy for Bluetooth")
    parser.add_argument('-v',
                        "--verbose",
                        action="store_true",
                        help="Print all packets using scapy to stdout")
    parser.add_argument(
        "-w", "--wait-time",
        required=False,
        type=float,
        help="Time to wait between sending two bytes"
    )
    args = parser.parse_args()
    args.in_pipe = ROOT.parent / "1.in"
    args.out_pipe = ROOT.parent / "1.out"
    args.injection_file = ROOT / "exp"
    if args.injection_file.exists():
        os.remove(args.injection_file)
    os.mkfifo(args.injection_file)
    # create pipes
    os.system("{}/create_pipes.sh 1".format(ROOT.parent))
    if args.verbose:
        from scapy.layers.bluetooth import HCI_Hdr
    while True:
        try:
            main(args)
        except KeyboardInterrupt:
            logger.success("[*] interrupted by user, bye!")
            break
        except Exception as e:
            logger.error("".format(e))
            break